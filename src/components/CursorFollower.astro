---
// src/components/CursorFollower.astro
// Card border glow - borders illuminate following mouse position
---

<style>
  /* ===== CARD BORDER GLOW OVERLAY (injected via JS) ===== */
  .glow-border-effect {
    position: absolute;
    inset: 0;
    border-radius: inherit;
    pointer-events: none;
    z-index: 2;
    opacity: 0;
    transition: opacity 0.35s ease;
    overflow: hidden;
  }

  /* The glowing border ring */
  .glow-border-ring {
    position: absolute;
    inset: 0;
    border-radius: inherit;
    padding: 1px;
    background: radial-gradient(
      400px circle at var(--glow-x, 50%) var(--glow-y, 50%),
      rgba(255, 255, 255, 0.4),
      rgba(255, 255, 255, 0.12) 35%,
      transparent 65%
    );
    -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
    -webkit-mask-composite: xor;
    mask-composite: exclude;
  }

  /* Subtle inner surface glow */
  .glow-border-fill {
    position: absolute;
    inset: 0;
    border-radius: inherit;
    background: radial-gradient(
      350px circle at var(--glow-x, 50%) var(--glow-y, 50%),
      rgba(255, 255, 255, 0.035),
      transparent 65%
    );
  }

  /* Hide on touch devices */
  @media (hover: none) and (pointer: coarse) {
    .glow-border-effect {
      display: none !important;
    }
  }
</style>

<script>
  let rafId = null;
  let eventCleanups = [];
  const injectedOverlays = new WeakMap();

  function cleanupCursorEffects() {
    if (rafId !== null) {
      cancelAnimationFrame(rafId);
      rafId = null;
    }
    eventCleanups.forEach(fn => fn());
    eventCleanups = [];
    document.querySelectorAll('.glow-border-effect').forEach(el => el.remove());
  }

  function initCursorEffects() {
    cleanupCursorEffects();

    const isTouchDevice = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
    const hasCoarsePointer = window.matchMedia('(pointer: coarse)').matches;
    if (isTouchDevice || hasCoarsePointer) return;

    let mouseX = 0, mouseY = 0;
    let needsUpdate = false;

    // ===== CARD BORDER GLOW =====
    const CARD_SELECTOR = '.card-dark, .glow-border';
    const GLOW_PROXIMITY = 80;

    // Cache card list - rebuild only on DOM changes
    let cards = [];

    function cacheCards() {
      cards = [];
      document.querySelectorAll(CARD_SELECTOR).forEach(card => {
        // Inject overlay if not already there
        if (!injectedOverlays.has(card)) {
          const pos = getComputedStyle(card).position;
          if (pos === 'static') card.style.position = 'relative';

          const overlay = document.createElement('div');
          overlay.className = 'glow-border-effect';
          overlay.innerHTML = '<div class="glow-border-ring"></div><div class="glow-border-fill"></div>';
          card.appendChild(overlay);
          injectedOverlays.set(card, overlay);
        }

        cards.push({ el: card, overlay: injectedOverlays.get(card) });
      });
    }

    function updateCardGlow() {
      for (const { el, overlay } of cards) {
        const rect = el.getBoundingClientRect();
        const nearX = mouseX >= rect.left - GLOW_PROXIMITY && mouseX <= rect.right + GLOW_PROXIMITY;
        const nearY = mouseY >= rect.top - GLOW_PROXIMITY && mouseY <= rect.bottom + GLOW_PROXIMITY;

        if (nearX && nearY) {
          const relX = mouseX - rect.left;
          const relY = mouseY - rect.top;

          const insideX = mouseX >= rect.left && mouseX <= rect.right;
          const insideY = mouseY >= rect.top && mouseY <= rect.bottom;
          let opacity = 1;

          if (!insideX || !insideY) {
            const distX = insideX ? 0 : Math.min(Math.abs(mouseX - rect.left), Math.abs(mouseX - rect.right));
            const distY = insideY ? 0 : Math.min(Math.abs(mouseY - rect.top), Math.abs(mouseY - rect.bottom));
            const dist = Math.sqrt(distX * distX + distY * distY);
            opacity = Math.max(0, 1 - dist / GLOW_PROXIMITY);
          }

          overlay.style.setProperty('--glow-x', `${relX}px`);
          overlay.style.setProperty('--glow-y', `${relY}px`);
          overlay.style.opacity = `${opacity}`;
        } else {
          if (overlay.style.opacity !== '0') {
            overlay.style.opacity = '0';
          }
        }
      }
    }

    // ===== ANIMATION LOOP - starts on demand, stops when idle =====
    let idleFrames = 0;
    const MAX_IDLE_FRAMES = 3;

    function animate() {
      if (needsUpdate) {
        updateCardGlow();
        needsUpdate = false;
        idleFrames = 0;
      } else {
        idleFrames++;
      }
      // Stop loop after a few idle frames to save battery
      if (idleFrames >= MAX_IDLE_FRAMES) {
        rafId = null;
        return;
      }
      rafId = requestAnimationFrame(animate);
    }

    function startLoop() {
      if (rafId === null) {
        idleFrames = 0;
        rafId = requestAnimationFrame(animate);
      }
    }

    // ===== MOUSE TRACKING =====
    const onMouseMove = (e) => {
      mouseX = e.clientX;
      mouseY = e.clientY;
      needsUpdate = true;
      startLoop();
    };
    document.addEventListener('mousemove', onMouseMove, { passive: true });
    eventCleanups.push(() => document.removeEventListener('mousemove', onMouseMove));

    // ===== INIT =====
    cacheCards();

    // Rebuild card cache when new elements appear - debounced
    let cacheTimeout = null;
    const debouncedCacheCards = () => {
      if (cacheTimeout) clearTimeout(cacheTimeout);
      cacheTimeout = setTimeout(cacheCards, 200);
    };
    const observer = new MutationObserver(debouncedCacheCards);
    observer.observe(document.body, { childList: true, subtree: true });
    eventCleanups.push(() => {
      observer.disconnect();
      if (cacheTimeout) clearTimeout(cacheTimeout);
    });
  }

  document.addEventListener('astro:page-load', initCursorEffects);
  document.addEventListener('astro:before-swap', cleanupCursorEffects);
</script>
