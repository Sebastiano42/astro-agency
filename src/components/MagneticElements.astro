---
// src/components/MagneticElements.astro
// LERP-based magnetic hover effect for interactive elements
---

<script>
  let magneticCleanups = [];
  let magneticRAF = null;

  function cleanupMagnetic() {
    if (magneticRAF !== null) {
      cancelAnimationFrame(magneticRAF);
      magneticRAF = null;
    }
    magneticCleanups.forEach(fn => fn());
    magneticCleanups = [];
  }

  function initMagneticEffect() {
    cleanupMagnetic();

    const magneticElements = document.querySelectorAll('.btn-primary, .btn-outline, .magnetic');
    if (!magneticElements.length) return;

    const isTouchDevice = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
    if (isTouchDevice) return;

    // Track each element's state for LERP animation
    const elementStates = new Map();

    magneticElements.forEach((element) => {
      const el = element;
      const state = { targetX: 0, targetY: 0, currentX: 0, currentY: 0, active: false, scale: 1, targetScale: 1 };
      elementStates.set(el, state);

      const handleMouseMove = (e) => {
        const rect = el.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;
        const deltaX = e.clientX - centerX;
        const deltaY = e.clientY - centerY;
        const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
        const maxDistance = Math.max(rect.width, rect.height) * 0.8;

        if (distance < maxDistance) {
          const strength = 0.3;
          const distanceFactor = 1 - (distance / maxDistance);
          state.targetX = deltaX * strength * distanceFactor;
          state.targetY = deltaY * strength * distanceFactor;
          state.targetScale = 1 + 0.04 * distanceFactor;
        }
      };

      const handleMouseEnter = () => {
        state.active = true;
        startMagneticLoop();
      };

      const handleMouseLeave = () => {
        state.active = false;
        state.targetX = 0;
        state.targetY = 0;
        state.targetScale = 1;
        startMagneticLoop();
      };

      el.addEventListener('mouseenter', handleMouseEnter);
      el.addEventListener('mousemove', handleMouseMove);
      el.addEventListener('mouseleave', handleMouseLeave);

      magneticCleanups.push(() => {
        el.removeEventListener('mouseenter', handleMouseEnter);
        el.removeEventListener('mousemove', handleMouseMove);
        el.removeEventListener('mouseleave', handleMouseLeave);
        el.style.transform = '';
        elementStates.delete(el);
      });
    });

    // Single animation loop - stops after idle frames to save CPU
    let idleFrames = 0;
    const MAX_IDLE = 3;

    function startMagneticLoop() {
      if (magneticRAF === null) {
        idleFrames = 0;
        magneticRAF = requestAnimationFrame(animateMagnetic);
      }
    }

    function animateMagnetic() {
      const LERP_IN = 0.1;
      const LERP_OUT = 0.08;
      let anyActive = false;

      elementStates.forEach((state, el) => {
        const lerp = state.active ? LERP_IN : LERP_OUT;
        state.currentX += (state.targetX - state.currentX) * lerp;
        state.currentY += (state.targetY - state.currentY) * lerp;
        state.scale += (state.targetScale - state.scale) * lerp;

        if (Math.abs(state.currentX) > 0.01 || Math.abs(state.currentY) > 0.01 || Math.abs(state.scale - 1) > 0.001) {
          el.style.transform = `translate(${state.currentX}px, ${state.currentY}px) scale(${state.scale})`;
          anyActive = true;
        } else if (!state.active) {
          el.style.transform = '';
        }
      });

      if (anyActive) {
        idleFrames = 0;
      } else {
        idleFrames++;
      }

      if (idleFrames >= MAX_IDLE) {
        magneticRAF = null;
        return;
      }

      magneticRAF = requestAnimationFrame(animateMagnetic);
    }
  }

  document.addEventListener('astro:page-load', initMagneticEffect);
  document.addEventListener('astro:before-swap', cleanupMagnetic);
</script>
